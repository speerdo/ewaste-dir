---
import { getAllCityStatePairs, type CityStatePair } from '../lib/cityData';
import { getCurrentLocation, reverseGeocode } from '../lib/geocoding';

interface Props {
  placeholder?: string;
  className?: string;
  variant?: 'hero' | 'nav';
}

const { placeholder = "Enter a city or zip code...", className = "", variant = "hero" } = Astro.props;

// Get all city-state pairs at build time
const cityStatePairs = await getAllCityStatePairs();

const id = variant === 'hero' ? 'hero' : 'nav';
---

<div class:list={["relative", className]} data-search-component={id}>
  <form id={`search-form-${id}`} class="relative flex" autocomplete="off">
    <input
      type="text"
      id={`search-input-${id}`}
      class:list={[
        "block w-full border-0 px-4 py-3 text-gray-900 shadow-sm placeholder:text-gray-400 sm:text-sm sm:leading-6 focus:ring-2 focus:ring-green-500 focus:border-transparent",
        variant === 'hero' 
          ? "rounded-l-lg" 
          : "rounded-full pl-10"
      ]}
      placeholder={placeholder}
      autocomplete="off"
    />
    {variant === 'hero' && (
      <button
        id={`search-button-${id}`}
        type="button"
        class="inline-flex items-center justify-center px-6 py-3 bg-green-600 text-white rounded-r-lg hover:bg-green-700 transition-colors"
      >
        <svg id={`search-icon-${id}`} xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
        <svg id={`spinner-${id}`} class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="ml-2 font-medium">Search</span>
      </button>
    )}
    <button
      id={`use-location-${id}`}
      type="button"
      class:list={[
        "flex items-center text-gray-400 hover:text-gray-500",
        variant === 'hero' 
          ? "absolute right-[120px] top-0 bottom-0 pr-3" 
          : "absolute right-3 top-1/2 -translate-y-1/2"
      ]}
      title="Use my location"
    >
      <svg id={`location-icon-${id}`} xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
      <svg id={`location-spinner-${id}`} class="animate-spin h-5 w-5 text-gray-400 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </button>
    <div id={`search-error-${id}`} class="absolute -bottom-6 left-0 right-0 text-red-500 text-xs bg-red-50 p-1 rounded hidden"></div>
  </form>

  <!-- Search Results -->
  <div 
    id={`search-results-${id}`}
    class="absolute left-0 right-0 top-full mt-1 bg-white rounded-lg shadow-lg border border-gray-200 hidden z-50 max-h-96 overflow-y-auto"
  >
    <div id={`results-content-${id}`} class="divide-y divide-gray-100"></div>
  </div>
</div>

<script define:vars={{ getCurrentLocation, reverseGeocode }} type="module">
  // Simple test script
  console.log('Script loaded!');

  // Set up window global
  if (typeof window !== 'undefined') {
    window.__CITY_STATE_PAIRS__ = window.__CITY_STATE_PAIRS__ || [];
  }
  
  // Set up once DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded!');
    
    // Find all search components
    document.querySelectorAll('[data-search-component]').forEach(component => {
      const id = component.getAttribute('data-search-component');
      console.log(`Found search component with ID: ${id}`);
      
      // Get elements for this search component
      const searchInput = document.getElementById(`search-input-${id}`);
      const searchButton = document.getElementById(`search-button-${id}`);
      const searchResults = document.getElementById(`search-results-${id}`);
      const resultsContent = document.getElementById(`results-content-${id}`);
      const useLocationBtn = document.getElementById(`use-location-${id}`);
      const searchForm = document.getElementById(`search-form-${id}`);
      
      // Exit if required elements not found
      if (!searchInput || !searchResults || !resultsContent) {
        console.error(`Missing required elements for search component ${id}`);
        return;
      }
      
      // Store global vars
      let searchTimeout;
      let cityStatePairs = []; // Will be populated from the server
      
      // Helper functions for UI feedback
      function showLoading(isLoading) {
        const searchIcon = document.getElementById(`search-icon-${id}`);
        const spinner = document.getElementById(`spinner-${id}`);
        const searchButton = document.getElementById(`search-button-${id}`);
        
        if (isLoading) {
          // Show loading state
          if (searchIcon && spinner) {
            searchIcon.classList.add('hidden');
            spinner.classList.remove('hidden');
          }
          if (searchButton) {
            searchButton.setAttribute('disabled', 'true');
          }
        } else {
          // Remove loading state
          if (searchIcon && spinner) {
            searchIcon.classList.remove('hidden');
            spinner.classList.add('hidden');
          }
          if (searchButton) {
            searchButton.removeAttribute('disabled');
          }
        }
      }
      
      function showLocationLoading(isLoading) {
        const locationIcon = document.getElementById(`location-icon-${id}`);
        const locationSpinner = document.getElementById(`location-spinner-${id}`);
        const useLocationBtn = document.getElementById(`use-location-${id}`);
        
        if (isLoading) {
          // Show loading state
          if (locationIcon && locationSpinner) {
            locationIcon.classList.add('hidden');
            locationSpinner.classList.remove('hidden');
          }
          if (useLocationBtn) {
            useLocationBtn.setAttribute('disabled', 'true');
          }
        } else {
          // Remove loading state
          if (locationIcon && locationSpinner) {
            locationIcon.classList.remove('hidden');
            locationSpinner.classList.add('hidden');
          }
          if (useLocationBtn) {
            useLocationBtn.removeAttribute('disabled');
          }
        }
      }
      
      function showError(message) {
        const errorEl = document.getElementById(`search-error-${id}`);
        if (errorEl) {
          errorEl.textContent = message;
          errorEl.classList.remove('hidden');
        }
      }
      
      function hideError() {
        const errorEl = document.getElementById(`search-error-${id}`);
        if (errorEl) {
          errorEl.classList.add('hidden');
        }
      }
      
      // Calculate distance between two coordinate points
      function calculateDistance(point1, point2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = toRad(point2.lat - point1.lat);
        const dLon = toRad(point2.lng - point1.lng);
        const lat1 = toRad(point1.lat);
        const lat2 = toRad(point2.lat);

        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function toRad(value) {
        return (value * Math.PI) / 180;
      }
      
      // Fetch city data from the server for client-side search
      console.log('Starting to fetch city data...');
      // Add cache buster to avoid cached data
      const cacheBuster = `?t=${Date.now()}`;
      const citiesDataUrl = `${window.location.origin}/api/cities-data${cacheBuster}`;
      console.log(`Using API URL: ${citiesDataUrl}`);
      fetch(citiesDataUrl)
        .then(response => {
          console.log(`Cities data API response status: ${response.status}`);
          return response.json();
        })
        .then(data => {
          console.log('Cities data received:', typeof data, Array.isArray(data) ? 'array of length ' + data.length : 'not an array');
          
          // Check if we got a wrapped response (for error cases)
          if (data && data.data && Array.isArray(data.data)) {
            console.log('Received wrapped data with message:', data.warning || data.error || 'No message');
            cityStatePairs = data.data;
          } else if (Array.isArray(data)) {
            cityStatePairs = data;
          } else {
            console.error('Unexpected data format:', typeof data, data);
            return;
          }
          
          console.log(`Loaded ${cityStatePairs.length} cities for search`);
          
          // Log if we have coordinates data
          const citiesWithCoords = cityStatePairs.filter(city => city.coordinates && city.coordinates.lat && city.coordinates.lng);
          console.log(`Cities with coordinates: ${citiesWithCoords.length} of ${cityStatePairs.length}`);
        })
        .catch(error => {
          console.error('Failed to load city data:', error);
          // Fallback to window.__CITY_STATE_PAIRS__ if available
          if (window.__CITY_STATE_PAIRS__ && window.__CITY_STATE_PAIRS__.length > 0) {
            console.log('Using fallback city data from global variable');
            cityStatePairs = window.__CITY_STATE_PAIRS__;
          }
        });
      
      // Use location button
      if (useLocationBtn) {
        useLocationBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          hideError();
          showLocationLoading(true);
          
          try {
            const location = await getCurrentLocation();
            if (!location) {
              throw new Error("Could not determine your location");
            }
            
            const geoData = await reverseGeocode(location);
            
            if (!geoData) {
              throw new Error("Could not find your location");
            }
            
            // Set the search input to the found location
            searchInput.value = `${geoData.city}, ${geoData.state}`;
            
            // Trigger a search with this location
            handleSearch();
          } catch (error) {
            console.error("Location error:", error);
            showError(error instanceof Error ? error.message : "Could not access your location");
          } finally {
            showLocationLoading(false);
          }
        });
      }
      
      // Search for matching cities/states
      function searchLocations(query) {
        console.log(`Searching for: "${query}"`);
        query = query.toLowerCase().trim();
        
        if (!query) return [];
        
        // Check for zip code
        const isZipCode = /^\d{5}(-\d{4})?$/.test(query);
        if (isZipCode) {
          return [{
            text: `Find recycling centers near ${query}`,
            type: 'zip',
            zip: query
          }];
        }
        
        // Try to find exact and partial matches
        const exactMatches = [];
        const partialMatches = [];
        
        // Check if cityStatePairs is available and not empty
        if (!cityStatePairs || cityStatePairs.length === 0) {
          showError("Search data is still loading. Please try again in a moment.");
          return [];
        }
        
        cityStatePairs.forEach(pair => {
          const cityLower = pair.city.toLowerCase();
          const stateLower = pair.state.toLowerCase();
          
          // Check for exact match
          if (cityLower === query || stateLower === query) {
            exactMatches.push({...pair, type: 'city'});
          }
          // Check for partial match
          else if (cityLower.includes(query) || stateLower.includes(query)) {
            partialMatches.push({...pair, type: 'city'});
          }
        });
        
        // Combine and limit results
        return [...exactMatches, ...partialMatches].slice(0, 8);
      }
      
      // Display search suggestions
      function showSuggestions(suggestions) {
        console.log(`Found ${suggestions.length} suggestions`);
        
        if (suggestions.length === 0) {
          searchResults?.classList.add('hidden');
          return;
        }
        
        // Generate suggestion HTML
        if (resultsContent) {
          resultsContent.innerHTML = suggestions
            .map(suggestion => {
              if (suggestion.type === 'zip') {
                return `
                  <button
                    type="button"
                    class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-2 group suggestion-item"
                    data-type="zip"
                    data-zip="${suggestion.zip}"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 group-hover:text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                    </svg>
                    <span>${suggestion.text}</span>
                  </button>
                `;
              }
              
              return `
                <button
                  type="button"
                  class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-2 group suggestion-item"
                  data-type="city" 
                  data-url="${suggestion.url}"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 group-hover:text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                  </svg>
                  <span>${suggestion.city}, ${suggestion.state}</span>
                </button>
              `;
            })
            .join('');
            
          // Add click handlers for suggestions
          resultsContent.querySelectorAll('.suggestion-item').forEach(button => {
            button.addEventListener('click', (e) => {
              e.preventDefault();
              const type = button.getAttribute('data-type');
              
              if (type === 'city') {
                const url = button.getAttribute('data-url');
                if (url) window.location.href = url;
              } else if (type === 'zip') {
                const zip = button.getAttribute('data-zip');
                if (zip) searchByZipCode(zip);
              }
            });
          });
        }
        
        // Show results dropdown
        searchResults?.classList.remove('hidden');
      }
      
      // ZIP code validation cache to reduce API calls
      const zipCodeCache = new Map();
      const ZIP_CACHE_DURATION = 1000 * 60 * 5; // 5 minutes
      
      // Explicitly clear the cache for testing
      function clearZipCache() {
        zipCodeCache.clear();
        console.log('ZIP code cache cleared');
      }
      
      // Main function for handling ZIP code search
      async function searchByZipCode(zipCode) {
        try {
          console.log(`Searching by ZIP code: ${zipCode}`);
          hideError();
          showLoading(true);

          // Show loading indicator in search results
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3">
                <svg class="animate-spin h-5 w-5 text-gray-400 inline mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>Finding recycling centers near ${zipCode}...</span>
              </div>
            `;
          }

          // Make sure this is a valid ZIP
          const zipRegex = /^\d{5}$/;
          if (!zipRegex.test(zipCode)) {
            console.log(`Invalid ZIP code format: ${zipCode}`);
            showError("Please enter a valid 5-digit ZIP code");
            showLoading(false);
            return;
          }

          // Create a unique cache key for this ZIP
          const cacheKey = `zip_${zipCode}_v2`; // Version suffix helps invalidate old cached data
          
          // Check the cache first
          const cachedZipData = zipCodeCache.get(cacheKey);
          if (cachedZipData && (Date.now() - cachedZipData.timestamp < ZIP_CACHE_DURATION)) {
            console.log(`Using cached data for ZIP ${zipCode}`);
            const data = cachedZipData.data;
            if (data) {
              processZipCodeData(zipCode, data);
              return;
            } else {
              console.log(`Cached data for ZIP ${zipCode} is invalid, clearing cache entry`);
              zipCodeCache.delete(cacheKey);
            }
          }
          
          // Generate a unique request ID to avoid caching issues
          const requestId = Date.now() + Math.floor(Math.random() * 1000);
          
          // Try multiple API request methods with retries
          let attempts = 0;
          const maxAttempts = 5; // Try all methods for all ZIP codes
          let data = null;
          let error = null;
          let attemptResponses = []; // Track response info for debugging

          while (attempts < maxAttempts && !data) {
            attempts++;
            try {
              console.log(`ZIP API attempt ${attempts}/${maxAttempts} for ${zipCode}`);
              
              // Build the API URL with different formats to overcome potential Vercel quirks
              let apiUrl;
              let fetchOptions = {
                headers: {
                  'Accept': 'application/json',
                  'Cache-Control': 'no-cache, no-store, must-revalidate',
                  'Pragma': 'no-cache',
                  'Expires': '0',
                  'X-Requested-With': 'fetch',
                  'X-Zip-Code': zipCode, // Add ZIP to headers for debugging
                  'X-Request-ID': requestId.toString() // Add a request ID to track
                },
                cache: 'no-store'
              };
              
              // Try a variety of request formats systematically for all ZIP codes
              if (attempts === 1) {
                // First attempt: using a path parameter (RESTful approach)
                apiUrl = `${window.location.origin}/api/zipcode/${zipCode}`;
                console.log(`Attempt 1: Using path parameter URL: ${apiUrl}`);
                fetchOptions.method = 'GET';
              } else if (attempts === 2) {
                // Second attempt: Use POST request with ZIP in body
                apiUrl = `${window.location.origin}/api/zipcode`;
                console.log(`Attempt 2: Using POST request to: ${apiUrl}`);
                fetchOptions.method = 'POST';
                fetchOptions.headers['Content-Type'] = 'application/json';
                fetchOptions.body = JSON.stringify({ 
                  zip: zipCode,
                  requestId: requestId
                });
              } else if (attempts === 3) {
                // Third attempt: Use POST request with form data
                apiUrl = `${window.location.origin}/api/zipcode`;
                console.log(`Attempt 3: Using POST with form data: ${apiUrl}`);
                fetchOptions.method = 'POST';
                delete fetchOptions.headers['Content-Type']; // Let the browser set this for form data
                const formData = new FormData();
                formData.append('zip', zipCode);
                formData.append('requestId', requestId);
                fetchOptions.body = formData;
              } else if (attempts === 4) {
                // Fourth attempt: Use alternative path format
                apiUrl = `${window.location.origin}/api/zipcode/postal/${zipCode}`;
                console.log(`Attempt 4: Using alternative path format: ${apiUrl}`);
                fetchOptions.method = 'GET';
              } else {
                // Fifth attempt: Use special POST with multiple fields
                apiUrl = `${window.location.origin}/api/zipcode`;
                console.log(`Attempt 5: Using POST with multiple fields: ${apiUrl}`);
                fetchOptions.method = 'POST';
                fetchOptions.headers['Content-Type'] = 'application/json';
                fetchOptions.body = JSON.stringify({ 
                  zip: zipCode,
                  zipCode: zipCode,
                  postal_code: zipCode,
                  zipcode: zipCode,
                  requestId: requestId
                });
              }
              
              console.log(`Fetching ZIP data from: ${apiUrl} (method: ${fetchOptions.method})`);
              const controller = new AbortController();
              const timeoutId = setTimeout(() => controller.abort(), 6000); // 6 second timeout for all requests
              
              try {
                fetchOptions.signal = controller.signal;
                const startTime = Date.now();
                console.log(`Request ${attempts} starting at ${new Date().toISOString()}`);
                
                const response = await fetch(apiUrl, fetchOptions);
                
                const endTime = Date.now();
                console.log(`Request ${attempts} completed in ${endTime - startTime}ms`);
                console.log(`Response status: ${response.status}`);
                
                // Log response headers for debugging
                const headers = {};
                response.headers.forEach((value, key) => {
                  headers[key] = value;
                });
                console.log(`Response headers:`, headers);
                
                clearTimeout(timeoutId);
                
                // Even if status is not 200, try to parse the response
                const responseData = await response.json();
                console.log(`ZIP data received (${response.status}):`, responseData);
                
                // Validate that the response is for the correct ZIP code
                if (responseData && responseData.requestedZip && 
                    responseData.requestedZip !== zipCode) {
                  console.error(`Response is for a different ZIP code! Requested: ${zipCode}, Got: ${responseData.requestedZip}`);
                  error = new Error(`ZIP code mismatch in response`);
                  continue; // Skip this response, it's for a different ZIP code
                }
                
                // Track this response for debugging
                attemptResponses.push({
                  attempt: attempts,
                  status: response.status,
                  duration: endTime - startTime,
                  data: responseData
                });
                
                // Check if we got a valid response or at least a fallback
                if (responseData && (responseData.city || (responseData.fallback && responseData.fallback.city))) {
                  // Use the main response or fallback if provided
                  data = responseData.city ? responseData : responseData.fallback;
                  console.log(`Success! Using data from attempt ${attempts}`);
                  break; // Success! Exit the retry loop
                } else {
                  console.log(`Invalid response format, will retry:`, responseData);
                  error = new Error(`Invalid response format on attempt ${attempts}`);
                }
              } catch (fetchError) {
                clearTimeout(timeoutId);
                console.error(`Fetch error on attempt ${attempts}:`, fetchError);
                attemptResponses.push({
                  attempt: attempts,
                  error: fetchError.message
                });
                error = fetchError;
                // Continue to next attempt
              }
            } catch (attemptError) {
              console.error(`Error in attempt ${attempts}:`, attemptError);
              attemptResponses.push({
                attempt: attempts,
                error: attemptError.message
              });
              error = attemptError;
            }
            
            // Small delay between retries
            if (attempts < maxAttempts) {
              const delayMs = 600; // Standard delay for all requests
              await new Promise(resolve => setTimeout(resolve, delayMs));
            }
          }
          
          // Log all attempt responses for debugging
          console.log(`ZIP code ${zipCode} attempt summary:`, attemptResponses);
          
          // If we've run out of attempts without success
          if (!data) {
            console.error(`All ${maxAttempts} API attempts failed:`, error);
            
            // See if we have any fallback data from previous errors
            if (error && error.fallback) {
              console.log(`Using fallback from error response:`, error.fallback);
              data = error.fallback;
            } else {
              // Make one final attempt to get a fallback location from the API
              try {
                console.log(`Making final fallback request to API`);
                const fallbackUrl = `${window.location.origin}/api/zipcode`;
                const fallbackResponse = await fetch(fallbackUrl, {
                  method: 'POST',
                  headers: {
                    'Accept': 'application/json',
                    'Content-Type': 'application/json',
                    'Cache-Control': 'no-cache',
                    'X-Zip-Code': zipCode, // Add ZIP to headers for debugging
                    'X-Request-ID': requestId.toString() // Add request ID
                  },
                  body: JSON.stringify({
                    fallback: true,
                    zip: zipCode,
                    requestId: requestId
                  }),
                  cache: 'no-store'
                });
                
                const fallbackData = await fallbackResponse.json();
                if (fallbackData && fallbackData.city) {
                  console.log(`Using API fallback data:`, fallbackData);
                  data = fallbackData;
                } else {
                  console.log(`Couldn't get fallback from API, redirecting to search page`);
                  window.location.href = `/search?q=${zipCode}`;
                  return;
                }
              } catch (fallbackError) {
                console.error(`Error getting fallback:`, fallbackError);
                // Redirect to search page as last resort
                window.location.href = `/search?q=${zipCode}`;
                return;
              }
            }
          }
          
          // Store in cache for future use - using the specific ZIP code as key
          if (data) {
            zipCodeCache.set(cacheKey, {
              data,
              timestamp: Date.now()
            });
          }
          
          // Process the data
          await processZipCodeData(zipCode, data);
        } catch (error) {
          console.error(`Error searching by zip: ${error.message || error}`);
          showError("Couldn't find that location. Please try a different search.");
          showLoading(false);
        }
      }
      
      // Process ZIP code data to find a matching city
      async function processZipCodeData(zipCode, data) {
        try {
          console.log(`Processing data for ZIP ${zipCode}:`, data);
          
          // If the API response includes a URL, use it directly
          if (data.url) {
            console.log(`Using direct URL from API response: ${data.url}`);
            
            // Force a small delay to ensure logs appear in console before redirect
            setTimeout(() => {
              window.location.href = data.url;
            }, 100);
            return;
          }
          
          // Special case for the fallback "Unknown Location"
          if (data.city === "Unknown Location" && data.state === "State Unknown") {
            console.log("Got fallback location data");
            
            // Check if we have a closest city recommendation
            if (data.closestCity && data.closestCity.city && data.closestCity.state) {
              console.log(`Redirecting to closest city: ${data.closestCity.city}, ${data.closestCity.state}`);
              
              // If closestCity has a URL, use it directly
              if (data.closestCity.url) {
                console.log(`Using URL from closestCity: ${data.closestCity.url}`);
                setTimeout(() => {
                  window.location.href = data.closestCity.url;
                }, 100);
                return;
              }
              
              // Format the URL for the closest city
              const citySlug = data.closestCity.city.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
              const stateSlug = data.closestCity.state.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
              const redirectUrl = `/states/${stateSlug}/${citySlug}`;
              
              console.log(`Redirecting to: ${redirectUrl}`);
              
              // Force a small delay to ensure logs appear in console before redirect
              setTimeout(() => {
                window.location.href = redirectUrl;
              }, 100);
              return;
            } else {
              // No closest city, fall back to search
              console.log("No closest city, redirecting to search page");
              window.location.href = `/search?q=${zipCode}`;
              return;
            }
          }
          
          // Format city and state correctly
          const cityToFind = data.city?.trim() || '';
          const stateToFind = data.state?.trim() || '';
          
          if (!cityToFind || !stateToFind) {
            console.error(`Missing city/state data for ZIP ${zipCode}:`, data);
            
            // Try using closestCity if available
            if (data.closestCity && data.closestCity.city && data.closestCity.state) {
              console.log(`Missing primary city/state, using closestCity instead:`, data.closestCity);
              
              // If closestCity has a URL, use it directly
              if (data.closestCity.url) {
                console.log(`Using URL from closestCity: ${data.closestCity.url}`);
                setTimeout(() => {
                  window.location.href = data.closestCity.url;
                }, 100);
                return;
              }
              
              // Format the URL for the closest city
              const citySlug = data.closestCity.city.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
              const stateSlug = data.closestCity.state.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
              const redirectUrl = `/states/${stateSlug}/${citySlug}`;
              
              console.log(`Redirecting to: ${redirectUrl}`);
              
              // Force a small delay to ensure logs appear in console before redirect
              setTimeout(() => {
                window.location.href = redirectUrl;
              }, 100);
              return;
            }
            
            throw new Error(`Could not extract city/state from data for ZIP ${zipCode}`);
          }
          
          console.log(`Looking for match for ${cityToFind}, ${stateToFind}`);
          
          // Find the matching city in our data
          let cityMatch = null;
          
          // First, try to find an exact match based on city and state
          const exactMatch = cityStatePairs.find(pair => 
            pair.city.toLowerCase() === cityToFind.toLowerCase() &&
            pair.state.toLowerCase() === stateToFind.toLowerCase()
          );
          
          if (exactMatch) {
            console.log(`Found exact match: ${exactMatch.city}, ${exactMatch.state}`);
            cityMatch = exactMatch;
          } else {
            // If no exact match, try just the city name
            const cityNameMatch = cityStatePairs.find(pair => 
              pair.city.toLowerCase() === cityToFind.toLowerCase()
            );
            
            if (cityNameMatch) {
              console.log(`Found match by city name: ${cityNameMatch.city}, ${cityNameMatch.state}`);
              cityMatch = cityNameMatch;
            } else {
              // Handle NYC boroughs specifically
              const nycBoroughs = ['manhattan', 'brooklyn', 'queens', 'bronx', 'staten island'];
              if (nycBoroughs.includes(cityToFind.toLowerCase()) && stateToFind.toLowerCase() === 'new york') {
                console.log(`Detected NYC borough: ${cityToFind}`);
                const nycMatch = cityStatePairs.find(pair => 
                  pair.city.toLowerCase() === 'new york' && 
                  pair.state.toLowerCase() === 'new york'
                );
                if (nycMatch) {
                  console.log(`Matched NYC borough to New York City`);
                  cityMatch = nycMatch;
                }
              }
              
              // If still no match, try to find nearest city using coordinates
              if (!cityMatch && data.coordinates && data.coordinates.lat && data.coordinates.lng) {
                console.log(`Trying distance-based matching with coordinates`);
                let nearestCity = null;
                let nearestDistance = Number.MAX_VALUE;
                
                cityStatePairs.forEach(pair => {
                  // Skip cities without coordinates
                  if (!pair.coordinates || !pair.coordinates.lat || !pair.coordinates.lng) {
                    return;
                  }
                  
                  // Skip cities in different states unless we have to
                  if (pair.state.toLowerCase() !== stateToFind.toLowerCase()) {
                    return;
                  }
                  
                  const distance = calculateDistance(
                    data.coordinates,
                    pair.coordinates
                  );
                  
                  if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestCity = pair;
                  }
                });
                
                if (nearestCity) {
                  console.log(`Found nearest city: ${nearestCity.city}, ${nearestCity.state} (${nearestDistance.toFixed(2)} km)`);
                  cityMatch = nearestCity;
                }
              }
            }
          }
          
          if (cityMatch) {
            window.location.href = cityMatch.url;
          } else {
            // Last resort: try to create a URL directly from city and state
            const citySlug = cityToFind.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            const stateSlug = stateToFind.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            const fallbackUrl = `/states/${stateSlug}/${citySlug}`;
            
            console.log(`No match found in cityStatePairs. Trying fallback URL: ${fallbackUrl}`);
            window.location.href = fallbackUrl;
          }
        } catch (error) {
          console.error(`Error processing ZIP data: ${error.message}`);
          showError("Couldn't find that location. Please try a different search.");
          showLoading(false);
        }
      }
      
      // Handle main search submission
      function handleSearch() {
        console.log('Search button clicked');
        const query = searchInput.value.trim();
        hideError();
        showLoading(true);
        
        if (query.length < 2) {
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3 text-red-500">
                <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Please enter a city name or ZIP code.
              </div>
            `;
          }
          searchResults?.classList.remove('hidden');
          showLoading(false);
          return;
        }

        // Check if this is a ZIP code search
        const isZipCode = /^\d{5}(-\d{4})?$/.test(query);
        if (isZipCode) {
          // Extract just the 5-digit ZIP if a 9-digit ZIP was entered
          const zipCode = query.substring(0, 5);
          searchByZipCode(zipCode);
          return;
        }

        // Otherwise, handle as a city search
        const suggestions = searchLocations(query);
        
        if (suggestions.length === 0) {
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3 text-red-500">
                <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                No recycling centers found for "${query}". Try entering a different city or a ZIP code.
              </div>
            `;
          }
          searchResults?.classList.remove('hidden');
          showLoading(false);
          return;
        }
        
        // If we have a direct match or only one result, go straight to that location
        if (suggestions.length === 1 || suggestions[0]?.text.toLowerCase() === query.toLowerCase()) {
          console.log(`Direct match found: ${suggestions[0].text}`);
          
          if (suggestions[0].type === 'zip') {
            searchByZipCode(suggestions[0].zip);
          } else {
            window.location.href = suggestions[0].url;
          }
          return;
        }
        
        // Show multiple suggestions
        showSuggestions(suggestions);
        showLoading(false);
      }
      
      // Set up event listeners
      
      // Input change - show suggestions as you type
      if (searchInput) {
        searchInput.addEventListener('input', () => {
          console.log(`Input changed: ${searchInput.value}`);
          if (searchTimeout) {
            clearTimeout(searchTimeout);
          }
          
          const query = searchInput.value.trim();
          if (query.length < 2) {
            searchResults?.classList.add('hidden');
            return;
          }
          
          searchTimeout = setTimeout(() => {
            const suggestions = searchLocations(query);
            showSuggestions(suggestions);
          }, 150);
        });
        
        // Handle Enter key press
        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleSearch();
          } else if (e.key === 'Escape') {
            searchResults?.classList.add('hidden');
          }
        });
      }
      
      // Search button click
      if (searchButton) {
        searchButton.addEventListener('click', (e) => {
          e.preventDefault();
          handleSearch();
        });
      }
      
      // Form submit
      if (searchForm) {
        searchForm.addEventListener('submit', (e) => {
          e.preventDefault();
          handleSearch();
          return false;
        });
      }
      
      // Close suggestions when clicking outside
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (searchInput && searchResults && !searchInput.contains(target) && !searchResults.contains(target)) {
          searchResults.classList.add('hidden');
        }
      });
    });
  });
</script>

<!-- Add global data for client-side access -->
<script define:vars={{ cityStatePairs }} type="module">
  // Make city data available to client-side scripts
  window.__CITY_STATE_PAIRS__ = cityStatePairs;
  
  // Debug output for global data
  console.log(`Set global city data with ${cityStatePairs.length} cities`);
  const withCoords = cityStatePairs.filter(city => city.coordinates && city.coordinates.lat && city.coordinates.lng);
  console.log(`Global city data with coordinates: ${withCoords.length}/${cityStatePairs.length}`);
  
  // Add more debug capabilities to window
  window.testZipCode = async function(zipCode) {
    console.log(`Debug testing ZIP code: ${zipCode}`);
    try {
      const cacheBuster = new Date().getTime();
      
      // Test all three methods
      const results = [];
      
      // Method 1: GET with path parameter
      try {
        const url1 = `${window.location.origin}/api/zipcode/${zipCode}`;
        console.log(`Method 1 - GET with path parameter: ${url1}`);
        
        const response1 = await fetch(url1, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Cache-Control': 'no-cache'
          }
        });
        
        console.log(`Method 1 response status: ${response1.status}`);
        const headers1 = {};
        response1.headers.forEach((value, key) => {
          headers1[key] = value;
        });
        console.log(`Method 1 response headers:`, headers1);
        
        const data1 = await response1.json();
        console.log(`Method 1 response data:`, data1);
        results.push({ method: 'GET path', status: response1.status, data: data1 });
      } catch (error1) {
        console.error(`Method 1 failed:`, error1);
        results.push({ method: 'GET path', error: error1.message });
      }
      
      // Method 2: GET with alternative path format
      try {
        const url2 = `${window.location.origin}/api/zipcode/postal/${zipCode}`;
        console.log(`Method 2 - GET with alternative path: ${url2}`);
        
        const response2 = await fetch(url2, {
          method: 'GET',
          headers: {
            'Accept': 'application/json',
            'Cache-Control': 'no-cache'
          }
        });
        
        console.log(`Method 2 response status: ${response2.status}`);
        const data2 = await response2.json();
        console.log(`Method 2 response data:`, data2);
        results.push({ method: 'GET alt path', status: response2.status, data: data2 });
      } catch (error2) {
        console.error(`Method 2 failed:`, error2);
        results.push({ method: 'GET alt path', error: error2.message });
      }
      
      // Method 3: POST with JSON body
      try {
        const url3 = `${window.location.origin}/api/zipcode`;
        console.log(`Method 3 - POST with JSON body: ${url3}`);
        
        const response3 = await fetch(url3, {
          method: 'POST',
          headers: {
            'Accept': 'application/json',
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          },
          body: JSON.stringify({ zip: zipCode })
        });
        
        console.log(`Method 3 response status: ${response3.status}`);
        const data3 = await response3.json();
        console.log(`Method 3 response data:`, data3);
        results.push({ method: 'POST', status: response3.status, data: data3 });
      } catch (error3) {
        console.error(`Method 3 failed:`, error3);
        results.push({ method: 'POST', error: error3.message });
      }
      
      console.table(results);
      return results;
    } catch (error) {
      console.error(`Test failed:`, error);
      return null;
    }
  };
</script>

---
import { getAllCityStatePairs, type CityStatePair } from '../lib/cityData';
import { getCurrentLocation, reverseGeocode } from '../lib/geocoding';

interface Props {
  placeholder?: string;
  className?: string;
  variant?: 'hero' | 'nav';
}

const { placeholder = "Enter a city or zip code...", className = "", variant = "hero" } = Astro.props;

// Get all city-state pairs at build time
const cityStatePairs = await getAllCityStatePairs();

const id = variant === 'hero' ? 'hero' : 'nav';
---

<div class:list={["relative", className]} data-search-component={id}>
  <form id={`search-form-${id}`} class="relative flex" autocomplete="off">
    <input
      type="text"
      id={`search-input-${id}`}
      class:list={[
        "block w-full border-0 px-4 py-3 text-gray-900 shadow-sm placeholder:text-gray-400 sm:text-sm sm:leading-6 focus:ring-2 focus:ring-green-500 focus:border-transparent",
        variant === 'hero' 
          ? "rounded-l-lg" 
          : "rounded-full pl-10"
      ]}
      placeholder={placeholder}
      autocomplete="off"
    />
    {variant === 'hero' && (
      <button
        id={`search-button-${id}`}
        type="button"
        class="inline-flex items-center justify-center px-6 py-3 bg-green-600 text-white rounded-r-lg hover:bg-green-700 transition-colors"
      >
        <svg id={`search-icon-${id}`} xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
        </svg>
        <svg id={`spinner-${id}`} class="animate-spin h-5 w-5 text-white hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <span class="ml-2 font-medium">Search</span>
      </button>
    )}
    <button
      id={`use-location-${id}`}
      type="button"
      class:list={[
        "flex items-center text-gray-400 hover:text-gray-500",
        variant === 'hero' 
          ? "absolute right-[120px] top-0 bottom-0 pr-3" 
          : "absolute right-3 top-1/2 -translate-y-1/2"
      ]}
      title="Use my location"
    >
      <svg id={`location-icon-${id}`} xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z" />
      </svg>
      <svg id={`location-spinner-${id}`} class="animate-spin h-5 w-5 text-gray-400 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </button>
    <div id={`search-error-${id}`} class="absolute -bottom-6 left-0 right-0 text-red-500 text-xs bg-red-50 p-1 rounded hidden"></div>
  </form>

  <!-- Search Results -->
  <div 
    id={`search-results-${id}`}
    class="absolute left-0 right-0 top-full mt-1 bg-white rounded-lg shadow-lg border border-gray-200 hidden z-50 max-h-96 overflow-y-auto"
  >
    <div id={`results-content-${id}`} class="divide-y divide-gray-100"></div>
  </div>
</div>

<script define:vars={{ getCurrentLocation, reverseGeocode }} type="module">
  // Simple test script
  console.log('Script loaded!');

  // Set up window global
  if (typeof window !== 'undefined') {
    window.__CITY_STATE_PAIRS__ = window.__CITY_STATE_PAIRS__ || [];
  }
  
  // Set up once DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    console.log('DOM loaded!');
    
    // Find all search components
    document.querySelectorAll('[data-search-component]').forEach(component => {
      const id = component.getAttribute('data-search-component');
      console.log(`Found search component with ID: ${id}`);
      
      // Get elements for this search component
      const searchInput = document.getElementById(`search-input-${id}`);
      const searchButton = document.getElementById(`search-button-${id}`);
      const searchResults = document.getElementById(`search-results-${id}`);
      const resultsContent = document.getElementById(`results-content-${id}`);
      const useLocationBtn = document.getElementById(`use-location-${id}`);
      const searchForm = document.getElementById(`search-form-${id}`);
      
      // Exit if required elements not found
      if (!searchInput || !searchResults || !resultsContent) {
        console.error(`Missing required elements for search component ${id}`);
        return;
      }
      
      // Store global vars
      let searchTimeout;
      let cityStatePairs = []; // Will be populated from the server
      
      // Helper functions for UI feedback
      function showLoading(isLoading) {
        const searchIcon = document.getElementById(`search-icon-${id}`);
        const spinner = document.getElementById(`spinner-${id}`);
        const searchButton = document.getElementById(`search-button-${id}`);
        
        if (isLoading) {
          // Show loading state
          if (searchIcon && spinner) {
            searchIcon.classList.add('hidden');
            spinner.classList.remove('hidden');
          }
          if (searchButton) {
            searchButton.setAttribute('disabled', 'true');
          }
        } else {
          // Remove loading state
          if (searchIcon && spinner) {
            searchIcon.classList.remove('hidden');
            spinner.classList.add('hidden');
          }
          if (searchButton) {
            searchButton.removeAttribute('disabled');
          }
        }
      }
      
      function showLocationLoading(isLoading) {
        const locationIcon = document.getElementById(`location-icon-${id}`);
        const locationSpinner = document.getElementById(`location-spinner-${id}`);
        const useLocationBtn = document.getElementById(`use-location-${id}`);
        
        if (isLoading) {
          // Show loading state
          if (locationIcon && locationSpinner) {
            locationIcon.classList.add('hidden');
            locationSpinner.classList.remove('hidden');
          }
          if (useLocationBtn) {
            useLocationBtn.setAttribute('disabled', 'true');
          }
        } else {
          // Remove loading state
          if (locationIcon && locationSpinner) {
            locationIcon.classList.remove('hidden');
            locationSpinner.classList.add('hidden');
          }
          if (useLocationBtn) {
            useLocationBtn.removeAttribute('disabled');
          }
        }
      }
      
      function showError(message) {
        const errorEl = document.getElementById(`search-error-${id}`);
        if (errorEl) {
          errorEl.textContent = message;
          errorEl.classList.remove('hidden');
        }
      }
      
      function hideError() {
        const errorEl = document.getElementById(`search-error-${id}`);
        if (errorEl) {
          errorEl.classList.add('hidden');
        }
      }
      
      // Calculate distance between two coordinate points
      function calculateDistance(point1, point2) {
        const R = 6371; // Earth's radius in kilometers
        const dLat = toRad(point2.lat - point1.lat);
        const dLon = toRad(point2.lng - point1.lng);
        const lat1 = toRad(point1.lat);
        const lat2 = toRad(point2.lat);

        const a =
          Math.sin(dLat / 2) * Math.sin(dLat / 2) +
          Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      function toRad(value) {
        return (value * Math.PI) / 180;
      }
      
      // Fetch city data from the server for client-side search
      console.log('Starting to fetch city data...');
      // Add cache buster to avoid cached data
      const cacheBuster = `?t=${Date.now()}`;
      const citiesDataUrl = `${window.location.origin}/api/cities-data${cacheBuster}`;
      console.log(`Using API URL: ${citiesDataUrl}`);
      fetch(citiesDataUrl)
        .then(response => {
          console.log(`Cities data API response status: ${response.status}`);
          return response.json();
        })
        .then(data => {
          // Check if we got a wrapped response (for error cases)
          if (data.data && Array.isArray(data.data)) {
            console.log('Received wrapped data with message:', data.warning || data.error || 'No message');
            cityStatePairs = data.data;
          } else if (Array.isArray(data)) {
            cityStatePairs = data;
          } else {
            console.error('Unexpected data format:', data);
            return;
          }
          
          console.log(`Loaded ${cityStatePairs.length} cities for search`);
          
          // Log if we have coordinates data
          const citiesWithCoords = cityStatePairs.filter(city => city.coordinates && city.coordinates.lat && city.coordinates.lng);
          console.log(`Cities with coordinates: ${citiesWithCoords.length} of ${cityStatePairs.length}`);
        })
        .catch(error => {
          console.error('Failed to load city data:', error);
        });
      
      // Use location button
      if (useLocationBtn) {
        useLocationBtn.addEventListener('click', async (e) => {
          e.preventDefault();
          hideError();
          showLocationLoading(true);
          
          try {
            const location = await getCurrentLocation();
            if (!location) {
              throw new Error("Could not determine your location");
            }
            
            const { latitude, longitude } = location;
            const geoData = await reverseGeocode(latitude, longitude);
            
            if (!geoData) {
              throw new Error("Could not find your location");
            }
            
            // Set the search input to the found location
            searchInput.value = `${geoData.city}, ${geoData.state}`;
            
            // Trigger a search with this location
            handleSearch();
          } catch (error) {
            console.error("Location error:", error);
            showError(error instanceof Error ? error.message : "Could not access your location");
          } finally {
            showLocationLoading(false);
          }
        });
      }
      
      // Search for matching cities/states
      function searchLocations(query) {
        console.log(`Searching for: "${query}"`);
        query = query.toLowerCase().trim();
        
        if (!query) return [];
        
        // Check for zip code
        const isZipCode = /^\d{5}(-\d{4})?$/.test(query);
        if (isZipCode) {
          return [{
            text: `Find recycling centers near ${query}`,
            type: 'zip',
            zip: query
          }];
        }
        
        // Try to find exact and partial matches
        const exactMatches = [];
        const partialMatches = [];
        
        // Check if cityStatePairs is available and not empty
        if (!cityStatePairs || cityStatePairs.length === 0) {
          showError("Search data is still loading. Please try again in a moment.");
          return [];
        }
        
        cityStatePairs.forEach(pair => {
          const cityLower = pair.city.toLowerCase();
          const stateLower = pair.state.toLowerCase();
          
          // Check for exact match
          if (cityLower === query || stateLower === query) {
            exactMatches.push({...pair, type: 'city'});
          }
          // Check for partial match
          else if (cityLower.includes(query) || stateLower.includes(query)) {
            partialMatches.push({...pair, type: 'city'});
          }
        });
        
        // Combine and limit results
        return [...exactMatches, ...partialMatches].slice(0, 8);
      }
      
      // Display search suggestions
      function showSuggestions(suggestions) {
        console.log(`Found ${suggestions.length} suggestions`);
        
        if (suggestions.length === 0) {
          searchResults?.classList.add('hidden');
          return;
        }
        
        // Generate suggestion HTML
        if (resultsContent) {
          resultsContent.innerHTML = suggestions
            .map(suggestion => {
              if (suggestion.type === 'zip') {
                return `
                  <button
                    type="button"
                    class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-2 group suggestion-item"
                    data-type="zip"
                    data-zip="${suggestion.zip}"
                  >
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 group-hover:text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                    </svg>
                    <span>${suggestion.text}</span>
                  </button>
                `;
              }
              
              return `
                <button
                  type="button"
                  class="w-full text-left px-4 py-3 hover:bg-gray-50 flex items-center gap-2 group suggestion-item"
                  data-type="city" 
                  data-url="${suggestion.url}"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-gray-400 group-hover:text-green-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z" />
                  </svg>
                  <span>${suggestion.city}, ${suggestion.state}</span>
                </button>
              `;
            })
            .join('');
            
          // Add click handlers for suggestions
          resultsContent.querySelectorAll('.suggestion-item').forEach(button => {
            button.addEventListener('click', (e) => {
              e.preventDefault();
              const type = button.getAttribute('data-type');
              
              if (type === 'city') {
                const url = button.getAttribute('data-url');
                if (url) window.location.href = url;
              } else if (type === 'zip') {
                const zip = button.getAttribute('data-zip');
                if (zip) searchByZipCode(zip);
              }
            });
          });
        }
        
        // Show results dropdown
        searchResults?.classList.remove('hidden');
      }
      
      // ZIP code validation cache to reduce API calls
      const zipCodeCache = new Map();
      const ZIP_CACHE_DURATION = 1000 * 60 * 15; // 15 minutes
      
      // Main function for handling ZIP code search
      async function searchByZipCode(zipCode) {
        showLoading(true);
        hideError();
        
        try {
          // Show loading indicator
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3">
                <svg class="animate-spin h-5 w-5 text-gray-400 inline mr-2" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                  <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                  <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <span>Finding recycling centers near ${zipCode}...</span>
              </div>
            `;
          }

          // Check the cache first
          const cachedZipData = zipCodeCache.get(zipCode);
          if (cachedZipData && (Date.now() - cachedZipData.timestamp < ZIP_CACHE_DURATION)) {
            console.log(`Using cached data for ZIP ${zipCode}`);
            const data = cachedZipData.data;
            processZipCodeData(zipCode, data);
            return;
          }

          // Fallback data for known ZIP codes in case API fails
          const fallbackZipData = {
            '10001': { city: 'New York', state: 'New York', coordinates: { lat: 40.7128, lng: -74.006 } },
            '10002': { city: 'New York', state: 'New York', coordinates: { lat: 40.7128, lng: -74.006 } },
            '90210': { city: 'Beverly Hills', state: 'California', coordinates: { lat: 34.0736, lng: -118.4004 } }
          };

          // Use our API to get location data
          const cacheBuster = new Date().getTime();
          const apiUrl = `${window.location.origin}/api/zipcode?zip=${zipCode}&_cb=${cacheBuster}`;
          
          let data;
          
          try {
            console.log(`Fetching ZIP data from: ${apiUrl}`);
            const response = await fetch(apiUrl, {
              headers: {
                'Accept': 'application/json',
                'Cache-Control': 'no-cache'
              }
            });
            
            if (!response.ok) {
              throw new Error(`API request failed with status ${response.status}`);
            }
            
            data = await response.json();
            
            if (!data || !data.city || !data.state) {
              throw new Error(`Invalid data received for ZIP ${zipCode}`);
            }
            
            // Store in cache for future use
            zipCodeCache.set(zipCode, {
              data,
              timestamp: Date.now()
            });
          } catch (error) {
            console.error(`API error for ZIP ${zipCode}:`, error);
            
            // If API call fails but we have a fallback for this ZIP, use it
            if (fallbackZipData[zipCode]) {
              console.log(`Using fallback data for ZIP ${zipCode}`);
              data = fallbackZipData[zipCode];
            } else {
              // No fallback available, rethrow the error
              throw error;
            }
          }
          
          // Process the data (moved to separate function)
          await processZipCodeData(zipCode, data);
        } catch (error) {
          console.error(`Error searching by zip: ${error.message}`);
          showError("Couldn't find that location. Please try a different search.");
          showLoading(false);
        }
      }
      
      // Process ZIP code data to find a matching city
      async function processZipCodeData(zipCode, data) {
        try {
          console.log(`Processing data for ZIP ${zipCode}:`, data);
          
          // Special case for the fallback "Unknown Location"
          if (data.city === "Unknown Location" && data.state === "State Unknown") {
            console.log("Got fallback location data, redirecting to search page");
            window.location.href = `/search?q=${zipCode}`;
            return;
          }
          
          // Format city and state correctly
          const cityToFind = data.city?.trim() || '';
          const stateToFind = data.state?.trim() || '';
          
          if (!cityToFind || !stateToFind) {
            console.error(`Missing city/state data for ZIP ${zipCode}:`, data);
            throw new Error(`Could not extract city/state from data for ZIP ${zipCode}`);
          }
          
          console.log(`Looking for match for ${cityToFind}, ${stateToFind}`);
          
          // Find the matching city in our data
          let cityMatch = null;
          
          // First, try to find an exact match based on city and state
          const exactMatch = cityStatePairs.find(pair => 
            pair.city.toLowerCase() === cityToFind.toLowerCase() &&
            pair.state.toLowerCase() === stateToFind.toLowerCase()
          );
          
          if (exactMatch) {
            console.log(`Found exact match: ${exactMatch.city}, ${exactMatch.state}`);
            cityMatch = exactMatch;
          } else {
            // If no exact match, try just the city name
            const cityNameMatch = cityStatePairs.find(pair => 
              pair.city.toLowerCase() === cityToFind.toLowerCase()
            );
            
            if (cityNameMatch) {
              console.log(`Found match by city name: ${cityNameMatch.city}, ${cityNameMatch.state}`);
              cityMatch = cityNameMatch;
            } else {
              // Handle NYC boroughs specifically
              const nycBoroughs = ['manhattan', 'brooklyn', 'queens', 'bronx', 'staten island'];
              if (nycBoroughs.includes(cityToFind.toLowerCase()) && stateToFind.toLowerCase() === 'new york') {
                console.log(`Detected NYC borough: ${cityToFind}`);
                const nycMatch = cityStatePairs.find(pair => 
                  pair.city.toLowerCase() === 'new york' && 
                  pair.state.toLowerCase() === 'new york'
                );
                if (nycMatch) {
                  console.log(`Matched NYC borough to New York City`);
                  cityMatch = nycMatch;
                }
              }
              
              // If still no match, try to find nearest city using coordinates
              if (!cityMatch && data.coordinates && data.coordinates.lat && data.coordinates.lng) {
                console.log(`Trying distance-based matching with coordinates`);
                let nearestCity = null;
                let nearestDistance = Number.MAX_VALUE;
                
                cityStatePairs.forEach(pair => {
                  // Skip cities without coordinates
                  if (!pair.coordinates || !pair.coordinates.lat || !pair.coordinates.lng) {
                    return;
                  }
                  
                  // Skip cities in different states unless we have to
                  if (pair.state.toLowerCase() !== stateToFind.toLowerCase()) {
                    return;
                  }
                  
                  const distance = calculateDistance(
                    data.coordinates,
                    pair.coordinates
                  );
                  
                  if (distance < nearestDistance) {
                    nearestDistance = distance;
                    nearestCity = pair;
                  }
                });
                
                if (nearestCity) {
                  console.log(`Found nearest city: ${nearestCity.city}, ${nearestCity.state} (${nearestDistance.toFixed(2)} km)`);
                  cityMatch = nearestCity;
                }
              }
            }
          }
          
          if (cityMatch) {
            window.location.href = cityMatch.url;
          } else {
            showError(`No matching city found for ${cityToFind}, ${stateToFind}. Please try a different search.`);
            showLoading(false);
          }
        } catch (error) {
          console.error(`Error processing ZIP data: ${error.message}`);
          showError("Couldn't find that location. Please try a different search.");
          showLoading(false);
        }
      }
      
      // Handle main search submission
      function handleSearch() {
        console.log('Search button clicked');
        const query = searchInput.value.trim();
        hideError();
        showLoading(true);
        
        if (query.length < 2) {
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3 text-red-500">
                <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Please enter a city name or ZIP code.
              </div>
            `;
          }
          searchResults?.classList.remove('hidden');
          showLoading(false);
          return;
        }

        // Check if this is a ZIP code search
        const isZipCode = /^\d{5}(-\d{4})?$/.test(query);
        if (isZipCode) {
          // Extract just the 5-digit ZIP if a 9-digit ZIP was entered
          const zipCode = query.substring(0, 5);
          searchByZipCode(zipCode);
          return;
        }

        // Otherwise, handle as a city search
        const suggestions = searchLocations(query);
        
        if (suggestions.length === 0) {
          if (resultsContent) {
            resultsContent.innerHTML = `
              <div class="px-4 py-3 text-red-500">
                <svg class="w-5 h-5 inline-block mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                No recycling centers found for "${query}". Try entering a different city or a ZIP code.
              </div>
            `;
          }
          searchResults?.classList.remove('hidden');
          showLoading(false);
          return;
        }
        
        // If we have a direct match or only one result, go straight to that location
        if (suggestions.length === 1 || suggestions[0]?.text.toLowerCase() === query.toLowerCase()) {
          console.log(`Direct match found: ${suggestions[0].text}`);
          
          if (suggestions[0].type === 'zip') {
            searchByZipCode(suggestions[0].zip);
          } else {
            window.location.href = suggestions[0].url;
          }
          return;
        }
        
        // Show multiple suggestions
        showSuggestions(suggestions);
        showLoading(false);
      }
      
      // Set up event listeners
      
      // Input change - show suggestions as you type
      if (searchInput) {
        searchInput.addEventListener('input', () => {
          console.log(`Input changed: ${searchInput.value}`);
          if (searchTimeout) {
            clearTimeout(searchTimeout);
          }
          
          const query = searchInput.value.trim();
          if (query.length < 2) {
            searchResults?.classList.add('hidden');
            return;
          }
          
          searchTimeout = setTimeout(() => {
            const suggestions = searchLocations(query);
            showSuggestions(suggestions);
          }, 150);
        });
        
        // Handle Enter key press
        searchInput.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleSearch();
          } else if (e.key === 'Escape') {
            searchResults?.classList.add('hidden');
          }
        });
      }
      
      // Search button click
      if (searchButton) {
        searchButton.addEventListener('click', (e) => {
          e.preventDefault();
          handleSearch();
        });
      }
      
      // Form submit
      if (searchForm) {
        searchForm.addEventListener('submit', (e) => {
          e.preventDefault();
          handleSearch();
          return false;
        });
      }
      
      // Close suggestions when clicking outside
      document.addEventListener('click', (e) => {
        const target = e.target;
        if (searchInput && searchResults && !searchInput.contains(target) && !searchResults.contains(target)) {
          searchResults.classList.add('hidden');
        }
      });
    });
  });
</script>

<!-- Add global data for client-side access -->
<script define:vars={{ cityStatePairs }} type="module">
  // Make city data available to client-side scripts
  window.__CITY_STATE_PAIRS__ = cityStatePairs;
  
  // Debug output for global data
  console.log(`Set global city data with ${cityStatePairs.length} cities`);
  const withCoords = cityStatePairs.filter(city => city.coordinates && city.coordinates.lat && city.coordinates.lng);
  console.log(`Global city data with coordinates: ${withCoords.length}/${cityStatePairs.length}`);
</script>
